<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Simultaneous Translator</title>
<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@300;400;500&family=IBM+Plex+Sans:wght@300;400;600&display=swap" rel="stylesheet">
<style>
  :root {
    --bg: #080c14;
    --surface: #0d1220;
    --surface2: #131929;
    --border: rgba(255,255,255,0.07);
    --accent: #00d4ff;
    --accent2: #7b61ff;
    --text: #e8edf7;
    --muted: #5a6478;
    --live: #00ff88;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'IBM Plex Sans', sans-serif;
    min-height: 100vh;
    overflow-x: hidden;
  }

  /* Scanline texture */
  body::before {
    content: '';
    position: fixed;
    inset: 0;
    background: repeating-linear-gradient(
      0deg,
      transparent,
      transparent 2px,
      rgba(0,0,0,0.03) 2px,
      rgba(0,0,0,0.03) 4px
    );
    pointer-events: none;
    z-index: 1000;
  }

  /* Background grid */
  body::after {
    content: '';
    position: fixed;
    inset: 0;
    background-image:
      linear-gradient(rgba(0,212,255,0.03) 1px, transparent 1px),
      linear-gradient(90deg, rgba(0,212,255,0.03) 1px, transparent 1px);
    background-size: 40px 40px;
    pointer-events: none;
  }

  header {
    padding: 20px 32px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    border-bottom: 1px solid var(--border);
    position: relative;
    z-index: 10;
  }

  .logo {
    display: flex;
    align-items: center;
    gap: 10px;
  }

  .logo-icon {
    width: 32px;
    height: 32px;
    border: 1.5px solid var(--accent);
    border-radius: 6px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
    color: var(--accent);
    position: relative;
    overflow: hidden;
  }

  .logo-icon::before {
    content: '';
    position: absolute;
    inset: 0;
    background: rgba(0,212,255,0.08);
  }

  .logo h1 {
    font-family: 'IBM Plex Mono', monospace;
    font-size: 14px;
    font-weight: 500;
    letter-spacing: 0.12em;
    text-transform: uppercase;
    color: var(--text);
  }

  .logo span {
    font-weight: 300;
    color: var(--muted);
  }

  .status-bar {
    display: flex;
    align-items: center;
    gap: 20px;
    font-family: 'IBM Plex Mono', monospace;
    font-size: 11px;
    color: var(--muted);
    letter-spacing: 0.08em;
  }

  .status-indicator {
    display: flex;
    align-items: center;
    gap: 6px;
  }

  .dot {
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background: var(--muted);
    transition: background 0.3s;
  }

  .dot.live {
    background: var(--live);
    box-shadow: 0 0 8px var(--live);
    animation: pulse 1.5s ease-in-out infinite;
  }

  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.4; }
  }

  .main {
    display: grid;
    grid-template-rows: auto 1fr;
    gap: 0;
    height: calc(100vh - 73px);
    position: relative;
    z-index: 10;
  }

  /* Control panel */
  .controls {
    padding: 20px 32px;
    border-bottom: 1px solid var(--border);
    display: flex;
    align-items: center;
    gap: 16px;
    flex-wrap: wrap;
  }

  .source-section {
    display: flex;
    align-items: center;
    gap: 10px;
  }

  label {
    font-size: 11px;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    color: var(--muted);
    font-family: 'IBM Plex Mono', monospace;
  }

  select {
    background: var(--surface2);
    border: 1px solid var(--border);
    color: var(--text);
    padding: 7px 12px;
    border-radius: 6px;
    font-family: 'IBM Plex Sans', sans-serif;
    font-size: 13px;
    cursor: pointer;
    outline: none;
    transition: border-color 0.2s;
  }

  select:focus { border-color: var(--accent); }

  .divider {
    width: 1px;
    height: 28px;
    background: var(--border);
  }

  .lang-toggles {
    display: flex;
    align-items: center;
    gap: 8px;
    flex-wrap: wrap;
    flex: 1;
  }

  .lang-tag {
    padding: 5px 12px;
    border-radius: 20px;
    border: 1px solid var(--border);
    font-size: 12px;
    cursor: pointer;
    transition: all 0.2s;
    user-select: none;
    font-family: 'IBM Plex Mono', monospace;
    letter-spacing: 0.05em;
    color: var(--muted);
  }

  .lang-tag.active {
    color: var(--text);
    border-color: transparent;
  }

  .mic-btn {
    margin-left: auto;
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 10px 24px;
    border-radius: 8px;
    border: 1.5px solid var(--accent);
    background: rgba(0,212,255,0.05);
    color: var(--accent);
    font-family: 'IBM Plex Mono', monospace;
    font-size: 13px;
    letter-spacing: 0.08em;
    cursor: pointer;
    transition: all 0.2s;
  }

  .mic-btn:hover {
    background: rgba(0,212,255,0.12);
    box-shadow: 0 0 20px rgba(0,212,255,0.15);
  }

  .mic-btn.recording {
    background: rgba(0,255,136,0.08);
    border-color: var(--live);
    color: var(--live);
    box-shadow: 0 0 20px rgba(0,255,136,0.15);
  }

  .mic-icon {
    font-size: 16px;
  }

  /* Content area */
  .content {
    display: grid;
    grid-template-columns: 340px 1fr;
    overflow: hidden;
  }

  /* Source panel */
  .source-panel {
    border-right: 1px solid var(--border);
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }

  .panel-header {
    padding: 14px 20px;
    border-bottom: 1px solid var(--border);
    font-family: 'IBM Plex Mono', monospace;
    font-size: 11px;
    letter-spacing: 0.12em;
    text-transform: uppercase;
    color: var(--muted);
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .panel-header .badge {
    padding: 2px 8px;
    border-radius: 3px;
    font-size: 10px;
    background: rgba(0,212,255,0.12);
    color: var(--accent);
    border: 1px solid rgba(0,212,255,0.2);
  }

  .transcript-area {
    flex: 1;
    padding: 20px;
    overflow-y: auto;
    font-size: 15px;
    line-height: 1.7;
    color: var(--text);
  }

  .transcript-area::-webkit-scrollbar {
    width: 4px;
  }
  .transcript-area::-webkit-scrollbar-track { background: transparent; }
  .transcript-area::-webkit-scrollbar-thumb {
    background: var(--border);
    border-radius: 2px;
  }

  .interim-text {
    color: var(--muted);
    font-style: italic;
  }

  .placeholder {
    color: var(--muted);
    font-size: 14px;
    margin-top: 20px;
    text-align: center;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
  }

  .placeholder .big-icon {
    font-size: 32px;
    opacity: 0.3;
    margin-bottom: 8px;
  }

  /* Translation grid */
  .translations-panel {
    overflow-y: auto;
    padding: 20px;
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
    gap: 16px;
    align-content: start;
  }

  .translations-panel::-webkit-scrollbar { width: 4px; }
  .translations-panel::-webkit-scrollbar-track { background: transparent; }
  .translations-panel::-webkit-scrollbar-thumb {
    background: var(--border);
    border-radius: 2px;
  }

  .translation-card {
    background: var(--surface);
    border: 1px solid var(--border);
    border-radius: 10px;
    overflow: hidden;
    transition: border-color 0.3s, box-shadow 0.3s;
    position: relative;
  }

  .translation-card.updating {
    border-color: rgba(123,97,255,0.4);
    box-shadow: 0 0 16px rgba(123,97,255,0.08);
  }

  .card-header {
    padding: 10px 16px;
    display: flex;
    align-items: center;
    gap: 8px;
    border-bottom: 1px solid var(--border);
  }

  .flag {
    font-size: 18px;
    line-height: 1;
  }

  .lang-name {
    font-size: 12px;
    font-family: 'IBM Plex Mono', monospace;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    font-weight: 500;
    flex: 1;
  }

  .card-status {
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background: var(--muted);
    transition: all 0.3s;
  }

  .card-status.thinking {
    background: var(--accent2);
    box-shadow: 0 0 6px var(--accent2);
    animation: pulse 0.8s ease-in-out infinite;
  }

  .card-status.done {
    background: var(--live);
    box-shadow: 0 0 6px var(--live);
    animation: none;
  }

  .card-body {
    padding: 14px 16px;
    font-size: 14px;
    line-height: 1.65;
    color: var(--text);
    min-height: 60px;
  }

  .card-body .empty {
    color: var(--muted);
    font-style: italic;
    font-size: 13px;
  }

  .typing-indicator {
    display: inline-flex;
    gap: 4px;
    align-items: center;
    margin-top: 4px;
  }

  .typing-indicator span {
    width: 4px;
    height: 4px;
    border-radius: 50%;
    background: var(--accent2);
    animation: bounce 0.9s ease-in-out infinite;
  }

  .typing-indicator span:nth-child(2) { animation-delay: 0.15s; }
  .typing-indicator span:nth-child(3) { animation-delay: 0.3s; }

  @keyframes bounce {
    0%, 60%, 100% { transform: translateY(0); opacity: 0.4; }
    30% { transform: translateY(-4px); opacity: 1; }
  }

  .waveform {
    display: flex;
    align-items: center;
    gap: 2px;
    height: 20px;
  }

  .wave-bar {
    width: 3px;
    border-radius: 2px;
    background: var(--live);
    animation: wave 0.8s ease-in-out infinite;
    transform-origin: bottom;
  }

  .wave-bar:nth-child(1) { animation-delay: 0s; height: 8px; }
  .wave-bar:nth-child(2) { animation-delay: 0.1s; height: 14px; }
  .wave-bar:nth-child(3) { animation-delay: 0.2s; height: 18px; }
  .wave-bar:nth-child(4) { animation-delay: 0.1s; height: 12px; }
  .wave-bar:nth-child(5) { animation-delay: 0s; height: 6px; }

  @keyframes wave {
    0%, 100% { transform: scaleY(0.5); opacity: 0.5; }
    50% { transform: scaleY(1); opacity: 1; }
  }

  .empty-state {
    grid-column: 1 / -1;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 60px 20px;
    color: var(--muted);
    text-align: center;
    gap: 12px;
  }

  .empty-state .big {
    font-size: 48px;
    opacity: 0.2;
  }

  .empty-state p {
    font-size: 14px;
    max-width: 300px;
    line-height: 1.6;
  }

  /* Language color accents */
  .lang-tag[data-lang="es"].active { background: rgba(255,180,0,0.15); border-color: rgba(255,180,0,0.4); color: #ffb400; }
  .lang-tag[data-lang="fr"].active { background: rgba(0,100,255,0.15); border-color: rgba(0,100,255,0.4); color: #6699ff; }
  .lang-tag[data-lang="de"].active { background: rgba(255,60,60,0.15); border-color: rgba(255,60,60,0.4); color: #ff6666; }
  .lang-tag[data-lang="zh"].active { background: rgba(255,80,0,0.12); border-color: rgba(255,80,0,0.4); color: #ff8040; }
  .lang-tag[data-lang="ja"].active { background: rgba(255,100,150,0.15); border-color: rgba(255,100,150,0.4); color: #ff80b0; }
  .lang-tag[data-lang="ar"].active { background: rgba(0,200,100,0.12); border-color: rgba(0,200,100,0.4); color: #00cc66; }
  .lang-tag[data-lang="pt"].active { background: rgba(0,180,80,0.12); border-color: rgba(0,180,80,0.4); color: #00cc55; }
  .lang-tag[data-lang="ru"].active { background: rgba(80,120,255,0.12); border-color: rgba(80,120,255,0.4); color: #8099ff; }
  .lang-tag[data-lang="ko"].active { background: rgba(180,80,255,0.12); border-color: rgba(180,80,255,0.4); color: #cc66ff; }
  .lang-tag[data-lang="hi"].active { background: rgba(255,140,0,0.12); border-color: rgba(255,140,0,0.4); color: #ff9900; }
  .lang-tag[data-lang="vi"].active { background: rgba(255,30,30,0.12); border-color: rgba(255,30,30,0.4); color: #ff5555; }

  .error-msg {
    background: rgba(255,60,60,0.08);
    border: 1px solid rgba(255,60,60,0.2);
    border-radius: 6px;
    padding: 10px 14px;
    font-size: 13px;
    color: #ff7777;
    margin: 10px 20px;
  }

  .card-footer {
    padding: 8px 16px;
    border-top: 1px solid var(--border);
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .speak-btn {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 5px 12px;
    border-radius: 5px;
    border: 1px solid var(--border);
    background: transparent;
    color: var(--muted);
    font-family: 'IBM Plex Mono', monospace;
    font-size: 11px;
    letter-spacing: 0.06em;
    cursor: pointer;
    transition: all 0.2s;
  }

  .speak-btn:hover:not(:disabled) {
    background: rgba(0,212,255,0.08);
    border-color: rgba(0,212,255,0.3);
    color: var(--accent);
  }

  .speak-btn.speaking {
    background: rgba(0,255,136,0.08);
    border-color: rgba(0,255,136,0.35);
    color: var(--live);
  }

  .speak-btn:disabled {
    opacity: 0.35;
    cursor: not-allowed;
  }

  .auto-btn {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 5px 12px;
    border-radius: 5px;
    border: 1px solid var(--border);
    background: transparent;
    color: var(--muted);
    font-family: 'IBM Plex Mono', monospace;
    font-size: 11px;
    letter-spacing: 0.06em;
    cursor: pointer;
    transition: all 0.2s;
    margin-left: auto;
  }

  .auto-btn.on {
    background: rgba(123,97,255,0.1);
    border-color: rgba(123,97,255,0.4);
    color: var(--accent2);
  }

  .auto-btn:hover {
    opacity: 0.8;
  }

  .speaking-wave {
    display: inline-flex;
    gap: 2px;
    align-items: center;
    height: 12px;
  }

  .speaking-wave span {
    width: 2px;
    border-radius: 1px;
    background: currentColor;
    animation: wave 0.6s ease-in-out infinite;
    transform-origin: bottom;
  }
  .speaking-wave span:nth-child(1) { height: 5px; animation-delay: 0s; }
  .speaking-wave span:nth-child(2) { height: 9px; animation-delay: 0.1s; }
  .speaking-wave span:nth-child(3) { height: 12px; animation-delay: 0.2s; }
  .speaking-wave span:nth-child(4) { height: 7px; animation-delay: 0.1s; }
</style>
</head>
<body>

<header>
  <div class="logo">
    <div class="logo-icon">‚¨°</div>
    <h1>POLYGLOT <span>// LIVE</span></h1>
  </div>
  <div class="status-bar">
    <div class="status-indicator">
      <div class="dot" id="liveDot"></div>
      <span id="statusText">STANDBY</span>
    </div>
    <div id="langCount">0 LANGUAGES</div>
  </div>
</header>

<div class="main">
  <div class="controls">
    <div class="source-section">
      <label>Source</label>
      <select id="sourceLang">
        <option value="en-US">English (US)</option>
        <option value="en-GB">English (UK)</option>
        <option value="es-ES">Spanish</option>
        <option value="fr-FR">French</option>
        <option value="de-DE">German</option>
        <option value="zh-CN">Mandarin</option>
        <option value="ja-JP">Japanese</option>
        <option value="pt-BR">Portuguese</option>
        <option value="ru-RU">Russian</option>
        <option value="ar-SA">Arabic</option>
      </select>
    </div>

    <div class="divider"></div>

    <label>Translate to:</label>
    <div class="lang-toggles" id="langToggles">
      <!-- populated by JS -->
    </div>

    <button class="mic-btn" id="micBtn" onclick="toggleRecording()">
      <span class="mic-icon">‚è∫</span>
      <span id="micBtnText">START</span>
    </button>
  </div>

  <div class="content">
    <div class="source-panel">
      <div class="panel-header">
        <span>Source Audio</span>
        <div id="waveformWrapper" style="display:none">
          <div class="waveform">
            <div class="wave-bar"></div>
            <div class="wave-bar"></div>
            <div class="wave-bar"></div>
            <div class="wave-bar"></div>
            <div class="wave-bar"></div>
          </div>
        </div>
        <div class="badge" id="sourceBadge">EN</div>
      </div>
      <div class="transcript-area" id="transcriptArea">
        <div class="placeholder" id="transcriptPlaceholder">
          <div class="big-icon">üéôÔ∏è</div>
          <span>Awaiting speech input</span>
          <span style="font-size:12px">Press START and begin speaking</span>
        </div>
      </div>
    </div>

    <div class="translations-panel" id="translationsPanel">
      <div class="empty-state" id="emptyState">
        <div class="big">‚¨°</div>
        <p>Select languages and start speaking to see real-time translations appear here.</p>
      </div>
    </div>
  </div>
</div>

<script>
const LANGUAGES = [
  { code: 'es', name: 'Spanish', flag: 'üá™üá∏', bcp: 'es-ES' },
  { code: 'fr', name: 'French', flag: 'üá´üá∑', bcp: 'fr-FR' },
  { code: 'de', name: 'German', flag: 'üá©üá™', bcp: 'de-DE' },
  { code: 'zh', name: 'Mandarin', flag: 'üá®üá≥', bcp: 'zh-CN' },
  { code: 'ja', name: 'Japanese', flag: 'üáØüáµ', bcp: 'ja-JP' },
  { code: 'ar', name: 'Arabic', flag: 'üá∏üá¶', bcp: 'ar-SA' },
  { code: 'pt', name: 'Portuguese', flag: 'üáßüá∑', bcp: 'pt-BR' },
  { code: 'ru', name: 'Russian', flag: 'üá∑üá∫', bcp: 'ru-RU' },
  { code: 'ko', name: 'Korean', flag: 'üá∞üá∑', bcp: 'ko-KR' },
  { code: 'hi', name: 'Hindi', flag: 'üáÆüá≥', bcp: 'hi-IN' },
  { code: 'vi', name: 'Vietnamese', flag: 'üáªüá≥', bcp: 'vi-VN' },
];

const LANG_NAMES = {
  es: 'Spanish', fr: 'French', de: 'German', zh: 'Mandarin Chinese',
  ja: 'Japanese', ar: 'Arabic', pt: 'Portuguese', ru: 'Russian',
  ko: 'Korean', hi: 'Hindi', vi: 'Vietnamese'
};

let activeLangs = new Set(['es', 'fr', 'de']);
let autoSpeak = new Set(); // langs with auto-speak on
let currentUtterance = null;
let speakingLang = null;
let recognition = null;
let isRecording = false;
let finalTranscript = '';
let translationDebounce = null;
let lastTranslated = '';

// Init language toggles
function initToggles() {
  const container = document.getElementById('langToggles');
  LANGUAGES.forEach(l => {
    const tag = document.createElement('div');
    tag.className = 'lang-tag' + (activeLangs.has(l.code) ? ' active' : '');
    tag.dataset.lang = l.code;
    tag.textContent = l.flag + ' ' + l.name;
    tag.onclick = () => {
      if (activeLangs.has(l.code)) {
        activeLangs.delete(l.code);
        tag.classList.remove('active');
      } else {
        activeLangs.add(l.code);
        tag.classList.add('active');
      }
      updateLangCount();
      renderCards();
    };
    container.appendChild(tag);
  });
  updateLangCount();
}

function updateLangCount() {
  document.getElementById('langCount').textContent = activeLangs.size + ' LANGUAGES';
}

// Render translation cards
function renderCards() {
  const panel = document.getElementById('translationsPanel');
  const empty = document.getElementById('emptyState');

  // Remove existing cards (not empty state)
  panel.querySelectorAll('.translation-card').forEach(c => c.remove());

  if (activeLangs.size === 0) {
    empty.style.display = 'flex';
    return;
  }
  empty.style.display = 'none';

  activeLangs.forEach(code => {
    if (document.getElementById('card-' + code)) return;
    const lang = LANGUAGES.find(l => l.code === code);
    const card = document.createElement('div');
    card.className = 'translation-card';
    card.id = 'card-' + code;
    card.innerHTML = `
      <div class="card-header">
        <span class="flag">${lang.flag}</span>
        <span class="lang-name">${lang.name}</span>
        <div class="card-status" id="status-${code}"></div>
      </div>
      <div class="card-body" id="body-${code}">
        <span class="empty">Waiting for speech...</span>
      </div>
      <div class="card-footer">
        <button class="speak-btn" id="speakBtn-${code}" onclick="speakLang('${code}')" disabled>
          ‚ñ∂ SPEAK
        </button>
        <button class="auto-btn ${autoSpeak.has(code) ? 'on' : ''}" id="autoBtn-${code}" onclick="toggleAutoSpeak('${code}')">
          ${autoSpeak.has(code) ? '‚ö° AUTO ON' : '‚ö° AUTO'}
        </button>
      </div>
    `;
    panel.appendChild(card);
  });
}

// Speech recognition
function toggleRecording() {
  if (isRecording) {
    stopRecording();
  } else {
    startRecording();
  }
}

function startRecording() {
  if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
    showError('Speech recognition is not supported in this browser. Please use Chrome or Edge.');
    return;
  }

  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  recognition = new SpeechRecognition();
  recognition.lang = document.getElementById('sourceLang').value;
  recognition.continuous = true;
  recognition.interimResults = true;

  recognition.onstart = () => {
    isRecording = true;
    document.getElementById('micBtn').classList.add('recording');
    document.getElementById('micBtnText').textContent = 'STOP';
    document.getElementById('liveDot').classList.add('live');
    document.getElementById('statusText').textContent = 'LIVE';
    document.getElementById('waveformWrapper').style.display = 'block';
  };

  recognition.onresult = (e) => {
    let interim = '';
    finalTranscript = '';

    for (let i = 0; i < e.results.length; i++) {
      if (e.results[i].isFinal) {
        finalTranscript += e.results[i][0].transcript;
      } else {
        interim += e.results[i][0].transcript;
      }
    }

    updateTranscript(finalTranscript, interim);

    // Debounce translation
    if (finalTranscript && finalTranscript !== lastTranslated) {
      clearTimeout(translationDebounce);
      translationDebounce = setTimeout(() => {
        translateText(finalTranscript);
        lastTranslated = finalTranscript;
      }, 600);
    }
  };

  recognition.onerror = (e) => {
    if (e.error !== 'no-speech') {
      showError('Speech recognition error: ' + e.error);
    }
  };

  recognition.onend = () => {
    if (isRecording) {
      // Auto-restart
      try { recognition.start(); } catch(e) {}
    }
  };

  recognition.start();
}

function stopRecording() {
  isRecording = false;
  if (recognition) recognition.stop();
  document.getElementById('micBtn').classList.remove('recording');
  document.getElementById('micBtnText').textContent = 'START';
  document.getElementById('liveDot').classList.remove('live');
  document.getElementById('statusText').textContent = 'STANDBY';
  document.getElementById('waveformWrapper').style.display = 'none';
}

function updateTranscript(final, interim) {
  const area = document.getElementById('transcriptArea');
  document.getElementById('transcriptPlaceholder')?.remove();

  let html = final ? `<span>${escapeHtml(final)}</span>` : '';
  if (interim) html += `<span class="interim-text"> ${escapeHtml(interim)}</span>`;
  area.innerHTML = html || '<div class="placeholder"><div class="big-icon">üéôÔ∏è</div><span>Speak now...</span></div>';
  area.scrollTop = area.scrollHeight;
}

function escapeHtml(text) {
  return text.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
}

// ‚îÄ‚îÄ Translation engine ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Uses MyMemory with retry + fallback to Google Translate unofficial endpoint.
// Requests are staggered (not all parallel) to avoid rate limiting.

const translationCache = {};

async function fetchMyMemory(text, from, to) {
  const targetCode = to === 'zh' ? 'zh-CN' : to;
  const langpair = from + '|' + targetCode;
  const url = 'https://api.mymemory.translated.net/get?q=' + encodeURIComponent(text) + '&langpair=' + encodeURIComponent(langpair);
  const res = await fetch(url);
  const data = await res.json();
  // MyMemory returns 429 or quota messages inside responseStatus
  if (data.responseStatus === 200 && data.responseData.translatedText &&
      !data.responseData.translatedText.toLowerCase().includes('mymemory')) {
    return data.responseData.translatedText;
  }
  return null;
}

async function fetchGoogleFree(text, from, to) {
  // Unofficial Google Translate endpoint ‚Äî no key needed, works reliably
  const targetCode = to === 'zh' ? 'zh-CN' : to;
  const url = 'https://translate.googleapis.com/translate_a/single?client=gtx&sl=' +
    encodeURIComponent(from) + '&tl=' + encodeURIComponent(targetCode) +
    '&dt=t&q=' + encodeURIComponent(text);
  const res = await fetch(url);
  const data = await res.json();
  // Response is nested arrays: [[["translated","original",...],...],...]
  if (data && data[0]) {
    return data[0].map(chunk => chunk[0]).filter(Boolean).join('');
  }
  return null;
}

async function translateOne(text, from, to, retries = 2) {
  const cacheKey = from + '|' + to + '|' + text;
  if (translationCache[cacheKey]) return translationCache[cacheKey];

  for (let attempt = 0; attempt <= retries; attempt++) {
    try {
      // Try Google free first ‚Äî more reliable and no daily quota issues
      const result = await fetchGoogleFree(text, from, to);
      if (result) {
        translationCache[cacheKey] = result;
        return result;
      }
    } catch(e) {}

    // Fallback: MyMemory
    try {
      const result = await fetchMyMemory(text, from, to);
      if (result) {
        translationCache[cacheKey] = result;
        return result;
      }
    } catch(e) {}

    // Wait before retry (exponential backoff)
    if (attempt < retries) await new Promise(r => setTimeout(r, 500 * (attempt + 1)));
  }
  return null;
}

async function translateText(text) {
  if (!text.trim() || activeLangs.size === 0) return;

  const langsToTranslate = [...activeLangs];
  const sourceLang = document.getElementById('sourceLang').value.split('-')[0];

  // Show thinking state on all cards
  langsToTranslate.forEach(code => {
    const body = document.getElementById('body-' + code);
    const status = document.getElementById('status-' + code);
    const card = document.getElementById('card-' + code);
    if (body) body.innerHTML = '<div class="typing-indicator"><span></span><span></span><span></span></div>';
    if (status) status.className = 'card-status thinking';
    if (card) card.classList.add('updating');
  });

  // Stagger requests slightly to avoid triggering rate limits
  const delay = ms => new Promise(r => setTimeout(r, ms));
  const results = await Promise.all(
    langsToTranslate.map(async (code, i) => {
      await delay(i * 80); // 80ms stagger between each language
      const translated = await translateOne(text, sourceLang, code);
      return { code, translated };
    })
  );

  results.forEach(({ code, translated }) => {
    const body = document.getElementById('body-' + code);
    const status = document.getElementById('status-' + code);
    const card = document.getElementById('card-' + code);
    const speakBtn = document.getElementById('speakBtn-' + code);
    if (body) body.innerHTML = translated ? escapeHtml(translated) : '<span class="empty">‚Äî retry in a moment ‚Äî</span>';
    if (status) status.className = translated ? 'card-status done' : 'card-status';
    if (card) card.classList.remove('updating');
    if (speakBtn) speakBtn.disabled = !translated;
    if (translated && autoSpeak.has(code)) speakText(translated, code);
  });
}

// ‚îÄ‚îÄ TTS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function speakLang(code) {
  const body = document.getElementById('body-' + code);
  if (!body) return;
  const text = body.innerText.trim();
  if (!text || text === 'Waiting for speech...' || text === 'Translation unavailable') return;
  speakText(text, code);
}

function speakText(text, code) {
  window.speechSynthesis.cancel();

  const lang = LANGUAGES.find(l => l.code === code);
  const utter = new SpeechSynthesisUtterance(text);
  utter.lang = lang.bcp;

  // Try to find a matching voice
  const voices = window.speechSynthesis.getVoices();
  const match = voices.find(v => v.lang.startsWith(code) || v.lang === lang.bcp);
  if (match) utter.voice = match;

  utter.rate = 0.95;
  utter.pitch = 1;

  // Update button state
  setSpeakingState(code, true);
  speakingLang = code;

  utter.onend = () => {
    setSpeakingState(code, false);
    speakingLang = null;
  };
  utter.onerror = () => {
    setSpeakingState(code, false);
    speakingLang = null;
  };

  window.speechSynthesis.speak(utter);
  currentUtterance = utter;
}

function setSpeakingState(code, speaking) {
  const btn = document.getElementById('speakBtn-' + code);
  if (!btn) return;
  if (speaking) {
    btn.classList.add('speaking');
    btn.innerHTML = `<span class="speaking-wave"><span></span><span></span><span></span><span></span></span> PLAYING`;
  } else {
    btn.classList.remove('speaking');
    btn.innerHTML = '‚ñ∂ SPEAK';
  }
}

function toggleAutoSpeak(code) {
  const btn = document.getElementById('autoBtn-' + code);
  if (autoSpeak.has(code)) {
    autoSpeak.delete(code);
    btn.classList.remove('on');
    btn.textContent = '‚ö° AUTO';
  } else {
    autoSpeak.add(code);
    btn.classList.add('on');
    btn.textContent = '‚ö° AUTO ON';
  }
}

function showError(msg) {
  const existing = document.querySelector('.error-msg');
  if (existing) existing.remove();

  const err = document.createElement('div');
  err.className = 'error-msg';
  err.textContent = msg;
  document.querySelector('.main').prepend(err);
  setTimeout(() => err.remove(), 6000);
}

// Init
initToggles();
renderCards();
</script>
</body>
</html>
